<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>LLM-Powered Data Engineering: Automating Schemas, Ingestion and Quality</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Reveal.js -->
  <link rel="stylesheet" href="https://unpkg.com/reveal.js/dist/reveal.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js/dist/theme/black.css">

  <!-- Custom minimal styling -->
  <style>
    body {
      background: #0e0e11;
    }
    .reveal h1, .reveal h2, .reveal h3 {
      letter-spacing: -0.02em;
    }
    .reveal h1 {
      font-size: 1.6em;
    }
    .reveal h2 {
      font-size: 1.2em;
    }
    .reveal p, .reveal li {
      font-size: 1.0em;
      color: #d1d1d6;
    }
    .muted {
      color: #8e8e93;
      font-size: 0.8em;
    }
    .accent {
      color: #7dd3fc;
    }
  </style>
</head>

<body>
<div class="reveal">
<div class="slides">

<!-- Slide 1 -->
<section>
  <h1>LLM-Powered Data Engineering</h1>
  <p class="accent">Automating Schemas, Ingestion and Quality</p>
  <p class="muted">Prudhvi Krovvidi · Hyderabad Python Meetup</p>
  <div style="text-align: center; margin-top: 1em;">
    <img src="assets/talk-qr.png" alt="Talk QR" style="max-width: 300px; height: auto; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
  </div>

  <aside class="notes">
    Hi, I'm Prudhvi.
    This talk is not a product pitch or a sales demo.
    
    What I want to share today is an open-source exploration of how LLMs can live inside real Python data pipelines, not outside them.
    We'll also do a live demo — not screenshots — so you can see this working end to end.
  </aside>
</section>

<!-- Slide 2 -->
<section>
  <h2>Data breaks late.</h2>
  <h2 class="accent">Schemas drift silently.</h2>

  <aside class="notes">
    Most of us here work with Python ETL in some form.
    Pipelines usually don't fail immediately when something changes — they fail late.
    
    Schema changes rarely come with alarms.
    A new field appears, a type subtly changes, a value becomes nullable — and nothing breaks right away.
    
    The problem shows up much later, when dbt tests fail, dashboards break, or downstream consumers start seeing bad data.
    
    By then, we're debugging history instead of preventing the issue.
  </aside>
</section>

<!-- Slide 3 -->
<section>
  <h2>Where we spend human time</h2>
  <ul>
    <li>Writing schemas</li>
    <li>Updating dbt tests</li>
    <li>Debugging mismatches</li>
  </ul>

  <aside class="notes">
    If you think about it, a lot of our time goes into:
    writing schema files,
    updating dbt tests,
    and debugging mismatches between Python and SQL.
    
    This is not creative work — it's translation work.
    Humans are repeatedly converting intent into checks.
  </aside>
</section>

<!-- Slide 4 -->
<section>
  <h2>LLMs are good at</h2>
  <h2 class="accent">reasoning, understanding context, not guessing</h2>

  <aside class="notes">
    When people hear "LLMs", they often think prompt-to-output magic.
    That's not what this is about.
    
    LLMs are actually very good at understanding structure, explaining change, and reasoning about compatibility.
    That maps extremely well to schema work.
  </aside>
</section>

<!-- Slide 5 -->
<section>
  <h2>Schemas are</h2>
  <h1 class="accent">living artifacts</h1>

  <aside class="notes">
    Schemas are not static contracts that you write once and forget.
    They evolve as data and business logic evolve.
    
    Humans already reason about schemas all the time:
    Is this breaking?
    Is this safe to deploy?
    
    SchemaForge is about automating that reasoning loop, not replacing humans.
  </aside>
</section>

<!-- Slide 6 -->
<section>
  <h2>What is <a href="https://prudhvi1709.github.io/schemaforge/" target="_blank">SchemaForge</a>?</h2>
  <ul>
    <li>Designed to plug into existing pipelines</li>
    <li>Schema reasoning engine</li>
    <li>dbt rule generator</li>
  </ul>

  <aside class="notes">
    SchemaForge is a Python-first schema reasoning engine.
    
    The end goal is not just to infer schemas, but to generate executable dbt data-quality rules that actually run inside your pipelines.
    Nothing here replaces Python or dbt — it augments them.
  </aside>
</section>

<!-- Slide 7 -->
<section>
  <h2>Where it fits</h2>
  <p><strong>Python ETL → SchemaForge → dbt tests → Warehouse</strong></p>

  <aside class="notes">
    Think of it like this:
    Python ETL produces data.
    SchemaForge reasons about structure and change.
    dbt enforces data quality.
    
    SchemaForge sits between ETL and enforcement.
    It's glue plus reasoning.
  </aside>
</section>

<!-- Slide 8 -->
<section>
  <h2>Live demo</h2>
  <ol>
    <li>Schema inference</li>
    <li>Evolution reasoning</li>
    <li>dbt rule generation</li>
  </ol>

  <aside class="notes">
    I'll switch to a live hosted instance now.
    
    As you watch, focus on three things:
    how the schema is inferred,
    how schema changes are reasoned about,
    and how dbt rules are generated.
    
    Let's jump into the demo.
    
    DEMO NARRATION:
    We start with raw or semi-structured data — the kind we usually see in pipelines.
    First, notice the schema inference. This isn't just about data types; there's semantic understanding here.
    Now I'll introduce a schema change. This is where humans usually pause and ask: "Is this breaking?"
    Finally, look at the dbt rules that are generated. These are real dbt-compatible tests that run in existing workflows.
    And importantly — your Python ETL stays exactly the same.
    
    If the demo slows down: Even without the UI, the key idea is that intent becomes executable checks.
  </aside>
</section>

<!-- Slide 9 -->
<section>
  <h2>How Python engineers benefit</h2>
  <ul>
    <li>Fewer manual checks</li>
    <li>Less schema drift</li>
    <li>Earlier failures</li>
  </ul>

  <aside class="notes">
    From a Python engineer's point of view, this means less manual schema maintenance.
    dbt tests don't lag behind reality, and failures are detected earlier.
    
    This is about leverage, not automation for automation's sake.
  </aside>
</section>

<!-- Slide 10 -->
<section>
  <h2>Integration patterns</h2>
  <ul>
    <li>Pre-commit schema checks</li>
    <li>CI-driven dbt test generation</li>
    <li>ETL validation hooks</li>
  </ul>

  <aside class="notes">
    In practice, this fits nicely into existing workflows.
    
    You can run SchemaForge as part of pre-commit checks,
    inside CI to generate dbt tests,
    or as validation hooks in Python ETL pipelines.
    
    Everything is deterministic, reviewable, and Git-friendly.
  </aside>
</section>

<!-- Slide 11 -->
<section>
    <h2>What stays the same</h2>
    <ul>
      <li>Python owns ETL</li>
      <li>dbt owns execution</li>
      <li>Humans own decisions</li>
    </ul>
  
    <aside class="notes">
      Python still owns ETL logic.
      dbt still executes all checks.
      Humans still own decisions and accountability.
      
      SchemaForge just reduces the translation burden.
    </aside>
  </section>
  

<!-- Slide 12 -->
<section>
  <h2>Connect & contribute</h2>
  <p class="muted">Scan the QR · Connect · Contribute</p>
  <img src="assets/qr.png" alt="QR Code" style="max-width: 200px; height: auto; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
  
  <aside class="notes">
    This is an open-source project.
    
    The QR code links to the live demo and the GitHub repo.
    Even if you don't use SchemaForge directly, the pattern itself is reusable.
    
    Happy to take questions — especially around pipeline integration, trade-offs, and where this approach may not fit.
    
    PERSONAL REMINDERS:
    Slow down.
    Pause before the demo.
    Let the demo breathe.
    Don't over-explain AI internals.
    Always anchor back to Python and dbt.
  </aside>
</section>

</div>
</div>

<script src="https://unpkg.com/reveal.js/dist/reveal.js"></script>
<script src="https://unpkg.com/reveal.js/plugin/notes/notes.js"></script>
<script>
  Reveal.initialize({
    hash: true,
    slideNumber: true,
    transition: 'fade',
    plugins: [ RevealNotes ]
  });
</script>
</body>
</html>
